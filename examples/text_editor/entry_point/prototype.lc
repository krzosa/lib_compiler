Inited: bool;
Perm: MA_Arena;
Transcripts: TranscriptStack;

SearchBar: TE.Buffer;
ResultsBuffer: TE.Buffer;

UpdatePrototype :: proc(rect: Rect2P, font: Font, font_size: float, font_spacing: float) {
    if !Inited {
        Inited = true;
        for iter := OS_IterateFiles(&Perm, S8("C:/video")); OS_IsValid(iter); OS_Advance(&iter) {
            if S8_EndsWith(iter.absolute_path, S8(".srt"), true) {
                printf("%.*s\n", :int(iter.absolute_path.len), iter.absolute_path.str);

                file_content := OS_ReadFile(&Perm, iter.absolute_path);
                PushTranscript(&Transcripts, {
                    absolute_path = STR(iter.absolute_path),
                    file_content = STR(file_content)});
            }
        }

        TE.AddWindow({buffer = &SearchBar});
        TE.AddWindow({buffer = &ResultsBuffer});
        TE.FocusedWindow = &TE.WindowStack[0];
        TE.FocusedWindow = nil;
    }

    for key := GetCharPressed(); key; key = GetCharPressed() {
        selection_range := :TE.Range{0,0};

        result: UTF8_Result = UTF32ToUTF8(:u32(key));
        if result.error == 0 {
            TE.ReplaceText(&SearchBar, selection_range, {:*char(&result.out_str[0]), result.len});
        } else {
            TE.ReplaceText(&SearchBar, selection_range, "?");
        }
    }



    // Te.ComputeWindowRects(rect);
    TE.WindowStack[0].rect = CutLeft(&rect, 0.5 * GetRectX(rect));
    TE.WindowStack[1].rect = CutLeft(&rect, 1.0 * GetRectX(rect));

    TE.UpdateAndDrawWindows(font, font_size);
}

S8 :: proc(str: String): S8_String { return {str = str.str, len = :i64(str.len)}; }
STR :: proc(str: S8_String): String { return {str = str.str, len = :int(str.len)}; }

Transcript :: struct {
    file_content: String;
    absolute_path: String;
}

TranscriptStack :: struct {
    data: [2048]Transcript;
    len: int;
}

PushTranscript :: proc(stack: *TranscriptStack, t: Transcript) {
    assert(stack.len + 1 < lengthof(stack.data));
    stack.data[stack.len] = t;
    stack.len += 1;
}
