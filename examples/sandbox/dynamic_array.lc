ArrayOfName :: struct {
    data: *Name;
    len:   int;
    cap:   int;
}

TryGrowingNameArray :: proc(arr: *ArrayOfName) {
    if (arr.len + 1 > arr.cap) {
        cap := arr.cap * 2;
        if (cap == 0) cap = 16;

        arr.data = libc.realloc(arr.data, sizeof(arr.data[0]) * :libc.size_t(cap));
        arr.cap  = cap;
    }
}

AddName :: proc(arr: *ArrayOfName, item: Name) {
    TryGrowingNameArray(arr);
    arr.data[arr.len] = item;
    arr.len += 1;
}

InsertName :: proc(a: *ArrayOfName, item: Name, index: int) {
    if index == a.len {
        AddName(a, item);
        return;
    }

    libc.assert(index < a.len);
    libc.assert(index >= 0);

    TryGrowingNameArray(a);
    right_len := :libc.size_t(a.len - index);
    libc.memmove(&a.data[index + 1], &a.data[index], sizeof(a.data[0]) * right_len);
    a.data[index] = item;
    a.len += 1;
}

GetLastName :: proc(a: ArrayOfName): *Name {
    libc.assert(a.len > 0);
    result := &a.data[a.len - 1];
    return result;
}

PopName :: proc(a: *ArrayOfName): Name {
    a.len -= 1;
    result := a.data[a.len];
    return result;
}